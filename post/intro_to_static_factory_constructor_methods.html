<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" />
        <meta name="description" content="" />
        <meta name="author" content="" />
        <title>Devin J. Cornell: Introduction to Static Factory Constructor Methods</title>
        <link rel="icon" type="image/x-icon" href="/assets/favicon.ico" />
        <!-- Font Awesome icons (free version)-->
        <!--<script src="https://use.fontawesome.com/releases/v5.15.3/js/all.js" crossorigin="anonymous"></script>-->
        <!-- Google fonts-->
        <link href="https://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic" rel="stylesheet" type="text/css" />
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css" />
        <!-- Core theme CSS (includes Bootstrap)-->
        <link href="/css/blog.css" rel="stylesheet" />
        <style>
            pre {
                background-color: #ececec;
                border-radius: 4px;
                padding: 10px;
            }
        </style>
    </head>
    <body>
        <!-- Navigation-->
        <nav class="navbar navbar-expand-lg navbar-light" id="mainNav">
            <div class="container px-4 px-lg-5">
                <p class="navbar-brand"><a href="/">devinjcornell.com</a><span>//</span><a href="/blog">Data Science Blog</a></p>
                <!--
                <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarResponsive" aria-controls="navbarResponsive" aria-expanded="false" aria-label="Toggle navigation">
                    Menu
                    <i class="fas fa-bars"></i>
                </button>
                <div class="collapse navbar-collapse" id="navbarResponsive">
                    <ul class="navbar-nav ms-auto py-4 py-lg-0">
                        This is what the unordered list elements looked like.
                        <li class="nav-item"><a class="nav-link px-lg-3 py-3 py-lg-4" href="index.html">Home</a></li>
                        <li class="nav-item"><a class="nav-link px-lg-3 py-3 py-lg-4" href="about.html">About</a></li>
                        <li class="nav-item"><a class="nav-link px-lg-3 py-3 py-lg-4" href="post.html">Sample Post</a></li>
                        <li class="nav-item"><a class="nav-link px-lg-3 py-3 py-lg-4" href="contact.html">Contact</a></li>
                    </ul>
                </div>
                -->
            </div>
        </nav>
        <!-- Page Header-->
        <header class="masthead" style="background-image: url('assets/img/post-bg.jpg')">
            <div class="container position-relative px-4 px-lg-5">
                <div class="row gx-4 gx-lg-5 justify-content-center">
                    <div class="col-md-10 col-lg-8 col-xl-8">
                        <div class="post-heading">
                            <h1>Introduction to Static Factory Constructor Methods</h1>
                            <h2 class="subheading">Change the way you initialize custom types in Python.</h2>
                            <span class="meta">
                                Posted by
                                <a href="/">Devin J. Cornell</a>
                                on Jun 14, 2024
                            </span>
                        </div>
                    </div>
                </div>
            </div>
        </header>
        <!-- Post Content-->
        <article class="mb-4">
            <div class="container px-4 px-lg-5">
                <div class="row gx-4 gx-lg-5 justify-content-center">
                    <div class="col-md-10 col-lg-8 col-xl-7">
                        <p>In this article, I show how we can use static factory constructor methods to initialize types instead of including complicated logic in <code>__init__</code> methods. A <strong><em>static factory constructor method</em></strong> (SFCM hereafter) is simply a static method which returns an instance of the object that implements it. A single class can have multiple SFCMs that accept different parameters, and the methods should contain any logic needed to initialize the object. While these methods are common in many software engineering applications, I believe they are especially important in data analysis code because they fit well with the way data flows through your program.</p>
<p><img alt="Static factory constructor method diagram." src="https://storage.googleapis.com/public_data_09324832787/static_factory_methods.svg" /></p>
<p>Here are a few benefits of implementing SFCMs for any type.</p>
<ul>
<li>A class can have multiple SFCMs, and therefore can be initialized in different ways from different source types. This means that the reader can easily see in the source code the various way the object may be initialized and the data from which it can be derived.</li>
<li>SFCM paramters can include data that is not intended to be stored in the object but is otherwise needed for initalization. This reduces the cases where partial/multi-stage initialization is the best option.</li>
<li>SFCMs are a superior alternative to overriding constructor methods when using inheritance. Subclasses can call SFCMs of parent classes explicitly instead of using <code>super()</code> or otherwise referring to the parent class (which may be especially useful in multiple-inheritance scenarios). This solves a number of challenges involved when inheriting from built-in types.</li>
</ul>
<p>If we look at the flow of data through our programs, you can see that SFCMs can handle all logic involved with transforming data from one type to another. As all data pipelines essentially follow the structure shown in the diagram below, we can see how SFCMs could be ubiquitous in your code.</p>
<p><img alt="Data flow control diagram." src="https://storage.googleapis.com/public_data_09324832787/sfcm_data_flow.svg" /></p>
<h2>Some Examples</h2>
<p>Now I'll show some examples of static factory constructor methods in Python. We typically create these methods using the <code>@classmethod</code> parameter, and they always return an instance of the containing class.</p>
<p>For example purposes, let us start by creating the most basic container object: a coordinate with <code>x</code> and <code>y</code> attributes. Users may more easily replicate this behavior using the <a href="https://docs.python.org/3/library/dataclasses.html"><code>dataclasses</code></a> module, but in this case the definition is very simple anyways. The <code>__init__</code> method simply takes <code>x</code> and <code>y</code> parameters and stores them as attributes. I include <code>x</code> and <code>y</code> as part of the definition to support type checkers. I also create basic <code>__repr__</code> and <code>__add__</code> methods.</p>
<pre><code>import typing
import math

class Coord:
    x: float
    y: float
    def __init__(self, x: float, y: float):
        self.x = x
        self.y = y

    def __repr__(self) -&gt; str:
        return f'{self.__class__.__name__}(x={self.x}, y={self.y})'

    def __add__(self, other: typing.Self) -&gt; typing.Self:
        return self.__class__(
            x = self.x + other.x,
            y = self.y + other.y,
        )
</code></pre>
<h3>Initializing with Common Values</h3>
<p>We can instantiate the object using <code>__init__</code> by passing both <code>x</code> and <code>y</code> in the calling function.</p>
<pre><code>Coord(0.0, 0.0)
</code></pre>
<p>The simplest possible static factory method could create an instance using no parameters at all. The coordinate where <code>x</code> and <code>y</code> equal zero is especially important in many scenarios, so let us say we want to create a static factory method so that every calling function need not use the literal 0.0 as parameters.</p>
<pre><code>    @classmethod
    def zero(cls) -&gt; typing.Self:
        return cls(x=0.0,y=0.0)
</code></pre>
<p>Calling <code>Coord.zero()</code> is cleaner than assigning <code>x = 0.0</code> and <code>y = 0.0</code> every time you need this coordinate.</p>
<h3>Use Non-data Parameters</h3>
<p>Now let us say we want a static factory method that includes data not meant to be stored in the object. Adding a <code>verbose</code> flag to the <code>__init__</code> method makes it a little unclear how it may be used. If the parameter is included in <code>__init__</code> for an otherwise data-only class, the user may assume that value will be stored and thus used later. If the flag is only included in the static factory method but not in the <code>__init__</code> method, we can guess that it may only be used on instantiation.</p>
<pre><code>    @classmethod
    def new(cls, x: float, y: float, verbose: bool = False) -&gt; typing.Self:
        o = cls(
            x = x,
            y = y,
        )
        if verbose:
            print(f'New {cls.__name__} was created: {o}')
        return o
</code></pre>
<h3>Situational Validation</h3>
<p>As another example, imagine we want to add validation code when instantiating in some scenarios, but not in others. One approach could be to add a <code>validate: bool</code> flag to the constructor, but we face the same readability point mentioned above. , we can use a static factory method: when the user does not need to validate the input (or perhaps the first case where they might expect invalid data), they can use <code>__init__</code>, otherwise, they can use a static factory method.</p>
<p>Here I demonstrate by creating a function which first makes sure that both <code>x</code> and <code>y</code> are finite values. This method should be used when coordinates with infinite values may be expected but not desired.</p>
<pre><code>    @classmethod
    def new_finite(cls, x: float, y: float) -&gt; typing.Self:
        invalids = (float('inf'), float('-inf'))
        if x in invalids or y in invalids:
            raise ValueError(f'x and y must be finite values.')
        return cls(
            x = x,
            y = y,
        )
</code></pre>
<h3>Co-dependent Parameters</h3>
<p>At times, the value of some parameters might be inferred or dependent on other parameters. This logic could always be done outside instantiation, but, if it is needed frequently enough, it might be worth adding to the same static factory method. Let us say we want to create a coordinate from a given value of <code>x</code> where <code>y</code> is a function of <code>x</code>. The static factory method needs only to include <code>x</code> in this case because we can calculate <code>y</code> from <code>x</code>. The following static factory method could be used to create a new instance of <code>Coord</code> from <code>x</code>.</p>
<pre><code>    @classmethod
    def from_quadratic(cls, x: float) -&gt; typing.Self:
        return cls(x=x, y=x**2)
</code></pre>
<p>Static factory methods can allow for more complicated relationships between the inputs and stored variables. In this example, we can instantiate the coord from <a href="https://www.mathsisfun.com/polar-cartesian-coordinates.html">polar coordinates</a>, and neither input is stored directly.</p>
<pre><code>    @classmethod
    def from_polar(cls, r: float, theta: float) -&gt; typing.Self:
        return cls(
            x = r * math.cos(theta),
            y = r * math.sin(theta),
        )

Coord.from_polar(1.0, math.pi / 3)
</code></pre>
<p>In the output we can see the computed result.</p>
<pre><code>Coord(x=0.5000000000000001, y=0.8660254037844386)
</code></pre>
<p>From these simple examples you can imagine a wide range of use cases where this might be the best solution. I will now show some of the most common.</p>
<h3>Instantiating Child Classes</h3>
<p>While inheritance should be used sparingly (consider composition-oriented approaches instead), they can be great in situations where you want to extend a class by adding new methods - including SFCMs. In this example, say we want to create a new coordinate type representing a coordinate which is derived from other coordinates. I create a new subclass with a new SFCM that relies on the previously created <code>.zero()</code> method. Only the new type has access to the new SFCM, but it can rely on SFCMs from the base class.</p>
<pre><code>class ResultCoord(Coord):
    '''Coordinate that results from an operation between other coordinates.'''
    @classmethod
    def from_sum_of_coords(cls, coords: typing.List[Coord]) -&gt; typing.Self:
        return sum(coords, start=cls.zero())

ResultCoord.from_sum_of_coords([Coord(0,1), Coord(10,4), Coord(11, 100)])
</code></pre>
<h3>Returning Multiple Instances</h3>
<p>In cases where it may be too tedious to create <a href="dsp1_data_collection_types.html">custom collection types</a>, SFCMs can be used to return collections of the implementing type. As an example, say we want to return a set of coordinates created by the reflection of the original point across the x and y axes. In that case, we can return a set of instances representing the desired coordinates.</p>
<pre><code>    @classmethod
    def from_reflected(cls, x: float, y: float) -&gt; typing.List[typing.Self]:
        return [
            cls(x = x, y = y),
            cls(x = -x, y = y),
            cls(x = x, y = -y),
            cls(x = -x, y = -y),
        ]
</code></pre>
<h3>Inheriting from Built-in Types</h3>
<p>SFCMs can be especially useful when creating types that inherit from built-in types. The following class inherits from the built-in <code>typing.List</code> type and is intended to store coordinates. The new type acts like a regular list except for the addition of the SFCM, which is especially useful because it can call the constructor (or another SFCM) of the contained type. Whenever the new collection appears, the reader knows it should contain only coordinates and should be created using a SFCM.</p>
<pre><code>class Coords(typing.List[Coord]):
    @classmethod
    def from_reflected_points(cls, x: float, y: float) -&gt; typing.List[typing.Self]:
        return cls([
            Coord(x = x, y = y),
            Coord(x = -x, y = y),
            Coord(x = x, y = -y),
            Coord(x = -x, y = -y),
        ])
Coords.from_reflected_points(1, 1)
</code></pre>
<h2>High-level Application: Custom Exceptions</h2>
<p>Now I will discuss one higher-level application of static factory methods: creating custom exceptions.</p>
<p>Start with an example where we want to create a custom exception that includes additional data to be used when it is caught up the call stack. We see this, for instance, in the <code>requests</code> module when raising generic HTTP errors: the request and response (along with HTTP error code) are attached to the exception type.</p>
<h3>Overriding <code>__init__</code></h3>
<p>One way to implement this is to override <code>__init__</code> to call <code>super().__init__</code> and then add the attribute dynamically. Every class can only have one <code>__init__</code> method, and so all users of this exception must provide the same data; in this case, only the error code, but in more complicated scenarios the downstream user may need to do more work.</p>
<pre><code>class MyError1(Exception):
    error_code: int

    def __init__(self, error_code: int):
        super().__init__(f'Received error with code {error_code}.')
        self.error_code: int
</code></pre>
<p>The function that wants to raise this exception should include the error code then.</p>
<pre><code>try:
    raise MyError1(500)
except MyError1 as e:
    print(e.error_code)
</code></pre>
<p>Note that we could create an exception hierarchy tree that allows us to get more specific, but too many custom exceptions can add a lot of clutter to your codebase.</p>
<h3>The static factory method approach</h3>
<p>Alternatively, we can create a static factory method that will instantiate the object using the default constructor and then bind the additional data. This way we do not need to provide <code>__super__</code>, and all subclasses can either use this method or define another, more specific method. Here I create a low-level method to bind the additional data, then two higher-level methods to generate the error code more specifically.</p>
<pre><code>class MyError2(Exception):
    error_code: int

    @classmethod
    def with_msg_code(cls, message: str, code: int) -&gt; typing.Self:
        o = cls(message)
        o.error_code = code
        return o

    @classmethod
    def from_error_code(cls, code: int) -&gt; typing.Self:
        return cls.with_msg_code(f'Encountered error {code}.', code=code)
</code></pre>
<p>The ability to create multiple static factory methods means we can further implement code-specific static factory methods that absolve the calling function from needing to provide the method directly. We simply use the method associated with the error we want to raise.</p>
<pre><code>    @classmethod
    def from_io_error(cls) -&gt; typing.Self:
        code = 500
        return cls.with_msg_code(f'Encountered IO error (error code {code}).', code=code)
</code></pre>
<p>We can also abstract away the error codes entirely, and check error code cases using additional properties.</p>
<pre><code>    @property
    def is_io_error(self) -&gt; bool:
        return self.error_code is 500
</code></pre>
<p>The benefit of this approach is that error codes can all be internally managed by the exception type and need not be provided by a calling or excepting function. We can continue to use a single exception type, and simply extend that type when we want to handle more cases. This supports a much higher level of logic complexity in the exception handling function.</p>
<h2>In Conclusion</h2>
<p>SFCMs are widely applicable in a number of data-oriented software design patterns, and I highly recommend integrating them into your workflow.</p>
<p>I have also mentioned using SFCMs in a number of other articles you can check out.</p>
<ul>
<li><a href="zods0_problem_with_dataframes.html">Are Data Frames too flexible?</a></li>
<li><a href="dsp1_data_collection_types.html">Patterns and Antipatterns for Dataclasses</a></li>
<li><a href="dsp1_data_collection_types.html">Patterns for data collection types</a></li>
</ul>
                    </div>
                </div>
            </div>
        </article>
        <!-- Footer-->
        <footer class="border-top">
            <div class="container px-4 px-lg-5">
                <div class="row gx-4 gx-lg-5 justify-content-center">
                    <div class="col-md-10 col-lg-8 col-xl-7">
                        <ul class="list-inline text-center">
                            <li class="list-inline-item">
                                <a href="#!">
                                    <span class="fa-stack fa-lg">
                                        <i class="fas fa-circle fa-stack-2x"></i>
                                        <i class="fab fa-twitter fa-stack-1x fa-inverse"></i>
                                    </span>
                                </a>
                            </li>
                            <li class="list-inline-item">
                                <a href="#!">
                                    <span class="fa-stack fa-lg">
                                        <i class="fas fa-circle fa-stack-2x"></i>
                                        <i class="fab fa-facebook-f fa-stack-1x fa-inverse"></i>
                                    </span>
                                </a>
                            </li>
                            <li class="list-inline-item">
                                <a href="#!">
                                    <span class="fa-stack fa-lg">
                                        <i class="fas fa-circle fa-stack-2x"></i>
                                        <i class="fab fa-github fa-stack-1x fa-inverse"></i>
                                    </span>
                                </a>
                            </li>
                        </ul>
                        <div class="small text-center text-muted fst-italic">Copyright &copy; Devin J. Cornell 2021<br/><hr/></div>
                    </div>
                </div>
            </div>
        </footer>
        <!-- Bootstrap core JS-->
        <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.0.1/dist/js/bootstrap.bundle.min.js"></script>
        <!-- Core theme JS-->
        <script src="/js/blog.js"></script>
    </body>
</html>